# Android Port Plan

This document captures the steps required to deliver an Android build of Pubky Swiss Knife with feature parity and minimal divergence from the desktop target.

## 1. Toolchain and environment

1. Install the Rust Android targets (`aarch64-linux-android`, `armv7-linux-androideabi`, `i686-linux-android`, `x86_64-linux-android`).
2. Install Android Studio, then use the SDK Manager to add the Android SDK, command-line tools, NDK (side-by-side), and CMake. Configure `JAVA_HOME`, `ANDROID_HOME`, `NDK_HOME`, and ensure the emulator binaries are on `PATH`.
3. Launch the Android emulator you plan to target before using `dx serve --android` for rapid feedback loops.

## 2. Share the desktop implementation

1. Keep the existing Dioxus component tree untouched and expose it through a library interface so both desktop and mobile launchers use the same root function. Dioxus mobile apps run inside the same webview renderer as desktop, so business logic and styling remain portable.
2. Reuse the desktop launch configuration (window title, canvas size) when compiling for desktop while switching to `LaunchBuilder::mobile()` on Android to hand control to the platform-specific entry points generated by the CLI. No UI rewrites are required because the renderer is shared.
3. Store shared assets (CSS, icons) in the crateâ€™s `assets` directory so the CLI can bundle them automatically for every target using `Dioxus.toml` configuration.

## 3. Configure bundling

1. Add a `Dioxus.toml` that declares the asset directory, web metadata, and bundle identifiers. This allows the CLI to align desktop and Android bundles with the same metadata surface.
2. Use `dx bundle` with the Android package type to produce signed or unsigned APKs alongside the existing desktop bundles. Custom signing material (JKS) can be injected later through the `bundle.android` section when we graduate from debug builds.

## 4. Verification and automation

1. Validate the Android build locally by running `dx bundle --platform android --package-type android` (or through the equivalent flag set) after the environment variables and emulator are ready. The CLI emits JSON describing the generated APK paths for easy scripting.
2. Mirror that command inside CI so GitHub Actions produce an unsigned debug APK artifact on every push. Keep the workflow focused on building (and optionally testing) so that signing can remain a separate release-time concern.
